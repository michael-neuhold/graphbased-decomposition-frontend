/* tslint:disable */
/* eslint-disable */
/**
 * Api Documentation
 * Api Documentation
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AbbreviatedObjectId
 */
export interface AbbreviatedObjectId {
    /**
     * 
     * @type {boolean}
     * @memberof AbbreviatedObjectId
     */
    'complete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AbbreviatedObjectId
     */
    'firstByte'?: number;
}
/**
 * 
 * @export
 * @interface ChangeEvent
 */
export interface ChangeEvent {
    /**
     * 
     * @type {string}
     * @memberof ChangeEvent
     */
    'authorEmailAddress'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChangeEvent
     */
    'changedFileNames'?: Array<string>;
    /**
     * 
     * @type {Array<DiffEntry>}
     * @memberof ChangeEvent
     */
    'changedfiles'?: Array<DiffEntry>;
    /**
     * 
     * @type {RevCommit}
     * @memberof ChangeEvent
     */
    'commitObject'?: RevCommit;
    /**
     * 
     * @type {number}
     * @memberof ChangeEvent
     */
    'timestampInSeconds'?: number;
}
/**
 * 
 * @export
 * @interface Charset
 */
export interface Charset {
    /**
     * 
     * @type {boolean}
     * @memberof Charset
     */
    'registered'?: boolean;
}
/**
 * 
 * @export
 * @interface ClassNode
 */
export interface ClassNode {
    /**
     * 
     * @type {string}
     * @memberof ClassNode
     */
    'className'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClassNode
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClassNode
     */
    'primaryKey'?: number;
}
/**
 * 
 * @export
 * @interface Component
 */
export interface Component {
    /**
     * 
     * @type {number}
     * @memberof Component
     */
    'id'?: number;
    /**
     * 
     * @type {Array<ClassNode>}
     * @memberof Component
     */
    'nodes'?: Array<ClassNode>;
}
/**
 * 
 * @export
 * @interface CouplingPerformanceMetricsDto
 */
export interface CouplingPerformanceMetricsDto {
    /**
     * 
     * @type {number}
     * @memberof CouplingPerformanceMetricsDto
     */
    'commitCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CouplingPerformanceMetricsDto
     */
    'executionTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof CouplingPerformanceMetricsDto
     */
    'historyLength'?: number;
    /**
     * 
     * @type {string}
     * @memberof CouplingPerformanceMetricsDto
     */
    'repositoryName'?: string;
}
/**
 * 
 * @export
 * @interface Decomposition
 */
export interface Decomposition {
    /**
     * 
     * @type {number}
     * @memberof Decomposition
     */
    'clusteringTime'?: number;
    /**
     * 
     * @type {Array<ChangeEvent>}
     * @memberof Decomposition
     */
    'history'?: Array<ChangeEvent>;
    /**
     * 
     * @type {number}
     * @memberof Decomposition
     */
    'id'?: number;
    /**
     * 
     * @type {DecompositionCouplingParameters}
     * @memberof Decomposition
     */
    'parameters'?: DecompositionCouplingParameters;
    /**
     * 
     * @type {GitRepository}
     * @memberof Decomposition
     */
    'repository'?: GitRepository;
    /**
     * 
     * @type {Array<Component>}
     * @memberof Decomposition
     */
    'services'?: Array<Component>;
    /**
     * 
     * @type {number}
     * @memberof Decomposition
     */
    'strategyTime'?: number;
}
/**
 * 
 * @export
 * @interface DecompositionCouplingParameters
 */
export interface DecompositionCouplingParameters {
    /**
     * 
     * @type {boolean}
     * @memberof DecompositionCouplingParameters
     */
    'contributorCoupling'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DecompositionCouplingParameters
     */
    'dependencyCoupling'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DecompositionCouplingParameters
     */
    'intervalSeconds'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DecompositionCouplingParameters
     */
    'logicalCoupling'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DecompositionCouplingParameters
     */
    'numServices'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DecompositionCouplingParameters
     */
    'semanticCoupling'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DecompositionCouplingParameters
     */
    'sizeThreshold'?: number;
}
/**
 * 
 * @export
 * @interface DecompositionCouplingParametersDto
 */
export interface DecompositionCouplingParametersDto {
    /**
     * 
     * @type {number}
     * @memberof DecompositionCouplingParametersDto
     */
    'classClusterThreshold'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DecompositionCouplingParametersDto
     */
    'contributorCoupling'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DecompositionCouplingParametersDto
     */
    'dependencyCoupling'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DecompositionCouplingParametersDto
     */
    'intervalSeconds'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DecompositionCouplingParametersDto
     */
    'logicalCoupling'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DecompositionCouplingParametersDto
     */
    'numberOfServices'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DecompositionCouplingParametersDto
     */
    'semanticCoupling'?: boolean;
}
/**
 * 
 * @export
 * @interface DecompositionDto
 */
export interface DecompositionDto {
    /**
     * 
     * @type {number}
     * @memberof DecompositionDto
     */
    'decompositionId'?: number;
    /**
     * 
     * @type {GitRepository}
     * @memberof DecompositionDto
     */
    'gitRepository'?: GitRepository;
    /**
     * 
     * @type {DecompositionCouplingParameters}
     * @memberof DecompositionDto
     */
    'parameters'?: DecompositionCouplingParameters;
}
/**
 * 
 * @export
 * @interface DiffEntry
 */
export interface DiffEntry {
    /**
     * 
     * @type {string}
     * @memberof DiffEntry
     */
    'changeType'?: DiffEntryChangeTypeEnum;
    /**
     * 
     * @type {AbbreviatedObjectId}
     * @memberof DiffEntry
     */
    'newId'?: AbbreviatedObjectId;
    /**
     * 
     * @type {FileMode}
     * @memberof DiffEntry
     */
    'newMode'?: FileMode;
    /**
     * 
     * @type {string}
     * @memberof DiffEntry
     */
    'newPath'?: string;
    /**
     * 
     * @type {AbbreviatedObjectId}
     * @memberof DiffEntry
     */
    'oldId'?: AbbreviatedObjectId;
    /**
     * 
     * @type {FileMode}
     * @memberof DiffEntry
     */
    'oldMode'?: FileMode;
    /**
     * 
     * @type {string}
     * @memberof DiffEntry
     */
    'oldPath'?: string;
    /**
     * 
     * @type {number}
     * @memberof DiffEntry
     */
    'score'?: number;
    /**
     * 
     * @type {number}
     * @memberof DiffEntry
     */
    'treeFilterMarks'?: number;
}

export const DiffEntryChangeTypeEnum = {
    Add: 'ADD',
    Modify: 'MODIFY',
    Delete: 'DELETE',
    Rename: 'RENAME',
    Copy: 'COPY'
} as const;

export type DiffEntryChangeTypeEnum = typeof DiffEntryChangeTypeEnum[keyof typeof DiffEntryChangeTypeEnum];

/**
 * 
 * @export
 * @interface EdgeRepresentation
 */
export interface EdgeRepresentation {
    /**
     * 
     * @type {number}
     * @memberof EdgeRepresentation
     */
    'from'?: number;
    /**
     * 
     * @type {number}
     * @memberof EdgeRepresentation
     */
    'to'?: number;
    /**
     * 
     * @type {number}
     * @memberof EdgeRepresentation
     */
    'weight'?: number;
}
/**
 * 
 * @export
 * @interface FileMode
 */
export interface FileMode {
    /**
     * 
     * @type {number}
     * @memberof FileMode
     */
    'bits'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileMode
     */
    'objectType'?: number;
}
/**
 * 
 * @export
 * @interface FooterLine
 */
export interface FooterLine {
    /**
     * 
     * @type {string}
     * @memberof FooterLine
     */
    'emailAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof FooterLine
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof FooterLine
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface GitRepository
 */
export interface GitRepository {
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'directoryName'?: string;
    /**
     * 
     * @type {number}
     * @memberof GitRepository
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'remotePath'?: string;
}
/**
 * 
 * @export
 * @interface GraphRepresentation
 */
export interface GraphRepresentation {
    /**
     * 
     * @type {number}
     * @memberof GraphRepresentation
     */
    'componentId'?: number;
    /**
     * 
     * @type {Array<EdgeRepresentation>}
     * @memberof GraphRepresentation
     */
    'edges'?: Array<EdgeRepresentation>;
    /**
     * 
     * @type {Array<NodeRepresentation>}
     * @memberof GraphRepresentation
     */
    'nodes'?: Array<NodeRepresentation>;
}
/**
 * 
 * @export
 * @interface GraphVisualizationDto
 */
export interface GraphVisualizationDto {
    /**
     * 
     * @type {Array<GraphVisualizationLinkDto>}
     * @memberof GraphVisualizationDto
     */
    'links'?: Array<GraphVisualizationLinkDto>;
    /**
     * 
     * @type {Array<GraphVisualizationNodeDto>}
     * @memberof GraphVisualizationDto
     */
    'nodes'?: Array<GraphVisualizationNodeDto>;
}
/**
 * 
 * @export
 * @interface GraphVisualizationLinkDto
 */
export interface GraphVisualizationLinkDto {
    /**
     * 
     * @type {number}
     * @memberof GraphVisualizationLinkDto
     */
    'source'?: number;
    /**
     * 
     * @type {number}
     * @memberof GraphVisualizationLinkDto
     */
    'target'?: number;
    /**
     * 
     * @type {number}
     * @memberof GraphVisualizationLinkDto
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface GraphVisualizationNodeDto
 */
export interface GraphVisualizationNodeDto {
    /**
     * 
     * @type {boolean}
     * @memberof GraphVisualizationNodeDto
     */
    'couldBeApi'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GraphVisualizationNodeDto
     */
    'group'?: number;
    /**
     * 
     * @type {number}
     * @memberof GraphVisualizationNodeDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GraphVisualizationNodeDto
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface ModelAndView
 */
export interface ModelAndView {
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    'empty'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ModelAndView
     */
    'model'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ModelAndView
     */
    'modelMap'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    'reference'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    'status'?: ModelAndViewStatusEnum;
    /**
     * 
     * @type {View}
     * @memberof ModelAndView
     */
    'view'?: View;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    'viewName'?: string;
}

export const ModelAndViewStatusEnum = {
    _100: '100',
    _101: '101',
    _102: '102',
    _103: '103',
    _200: '200',
    _201: '201',
    _202: '202',
    _203: '203',
    _204: '204',
    _205: '205',
    _206: '206',
    _207: '207',
    _208: '208',
    _226: '226',
    _300: '300',
    _301: '301',
    _302: '302',
    _303: '303',
    _304: '304',
    _305: '305',
    _307: '307',
    _308: '308',
    _400: '400',
    _401: '401',
    _402: '402',
    _403: '403',
    _404: '404',
    _405: '405',
    _406: '406',
    _407: '407',
    _408: '408',
    _409: '409',
    _410: '410',
    _411: '411',
    _412: '412',
    _413: '413',
    _414: '414',
    _415: '415',
    _416: '416',
    _417: '417',
    _418: '418',
    _419: '419',
    _420: '420',
    _421: '421',
    _422: '422',
    _423: '423',
    _424: '424',
    _426: '426',
    _428: '428',
    _429: '429',
    _431: '431',
    _451: '451',
    _500: '500',
    _501: '501',
    _502: '502',
    _503: '503',
    _504: '504',
    _505: '505',
    _506: '506',
    _507: '507',
    _508: '508',
    _509: '509',
    _510: '510',
    _511: '511'
} as const;

export type ModelAndViewStatusEnum = typeof ModelAndViewStatusEnum[keyof typeof ModelAndViewStatusEnum];

/**
 * 
 * @export
 * @interface MonolithCouplingParametersDto
 */
export interface MonolithCouplingParametersDto {
    /**
     * 
     * @type {boolean}
     * @memberof MonolithCouplingParametersDto
     */
    'contributorCoupling'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MonolithCouplingParametersDto
     */
    'dependencyCoupling'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MonolithCouplingParametersDto
     */
    'intervalSeconds'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MonolithCouplingParametersDto
     */
    'logicalCoupling'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MonolithCouplingParametersDto
     */
    'semanticCoupling'?: boolean;
}
/**
 * 
 * @export
 * @interface NodeRepresentation
 */
export interface NodeRepresentation {
    /**
     * 
     * @type {string}
     * @memberof NodeRepresentation
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeRepresentation
     */
    'fullClassName'?: string;
    /**
     * 
     * @type {number}
     * @memberof NodeRepresentation
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof NodeRepresentation
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface ObjectId
 */
export interface ObjectId {
    /**
     * 
     * @type {number}
     * @memberof ObjectId
     */
    'firstByte'?: number;
    /**
     * 
     * @type {string}
     * @memberof ObjectId
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PerformanceMetricsDto
 */
export interface PerformanceMetricsDto {
    /**
     * 
     * @type {Array<CouplingPerformanceMetricsDto>}
     * @memberof PerformanceMetricsDto
     */
    'contributorCouplingPerformanceMetric'?: Array<CouplingPerformanceMetricsDto>;
    /**
     * 
     * @type {Array<CouplingPerformanceMetricsDto>}
     * @memberof PerformanceMetricsDto
     */
    'dependencyCouplingPerformanceMetric'?: Array<CouplingPerformanceMetricsDto>;
    /**
     * 
     * @type {Array<CouplingPerformanceMetricsDto>}
     * @memberof PerformanceMetricsDto
     */
    'logicalCouplingPerformanceMetric'?: Array<CouplingPerformanceMetricsDto>;
    /**
     * 
     * @type {Array<CouplingPerformanceMetricsDto>}
     * @memberof PerformanceMetricsDto
     */
    'semanticCouplingPerformanceMetric'?: Array<CouplingPerformanceMetricsDto>;
}
/**
 * 
 * @export
 * @interface PersonIdent
 */
export interface PersonIdent {
    /**
     * 
     * @type {string}
     * @memberof PersonIdent
     */
    'emailAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonIdent
     */
    'name'?: string;
    /**
     * 
     * @type {TimeZone}
     * @memberof PersonIdent
     */
    'timeZone'?: TimeZone;
    /**
     * 
     * @type {number}
     * @memberof PersonIdent
     */
    'timeZoneOffset'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonIdent
     */
    'when'?: string;
}
/**
 * 
 * @export
 * @interface QualityMetricDto
 */
export interface QualityMetricDto {
    /**
     * 
     * @type {number}
     * @memberof QualityMetricDto
     */
    'averageClassCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof QualityMetricDto
     */
    'averageLoc'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof QualityMetricDto
     */
    'contributorCoupling'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof QualityMetricDto
     */
    'contributorOverlapping'?: number;
    /**
     * 
     * @type {number}
     * @memberof QualityMetricDto
     */
    'contributorsPerMicroservice'?: number;
    /**
     * 
     * @type {number}
     * @memberof QualityMetricDto
     */
    'decompositionId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof QualityMetricDto
     */
    'dependencyCoupling'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QualityMetricDto
     */
    'logicalCoupling'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof QualityMetricDto
     */
    'numberOfServices'?: number;
    /**
     * 
     * @type {number}
     * @memberof QualityMetricDto
     */
    'repositoryId'?: number;
    /**
     * 
     * @type {string}
     * @memberof QualityMetricDto
     */
    'repositoryName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QualityMetricDto
     */
    'semanticCoupling'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof QualityMetricDto
     */
    'similarity'?: number;
}
/**
 * 
 * @export
 * @interface RepositoryDto
 */
export interface RepositoryDto {
    /**
     * 
     * @type {string}
     * @memberof RepositoryDto
     */
    'uri'?: string;
}
/**
 * 
 * @export
 * @interface RevCommit
 */
export interface RevCommit {
    /**
     * 
     * @type {PersonIdent}
     * @memberof RevCommit
     */
    'authorIdent'?: PersonIdent;
    /**
     * 
     * @type {number}
     * @memberof RevCommit
     */
    'commitTime'?: number;
    /**
     * 
     * @type {PersonIdent}
     * @memberof RevCommit
     */
    'committerIdent'?: PersonIdent;
    /**
     * 
     * @type {Charset}
     * @memberof RevCommit
     */
    'encoding'?: Charset;
    /**
     * 
     * @type {string}
     * @memberof RevCommit
     */
    'encodingName'?: string;
    /**
     * 
     * @type {number}
     * @memberof RevCommit
     */
    'firstByte'?: number;
    /**
     * 
     * @type {Array<FooterLine>}
     * @memberof RevCommit
     */
    'footerLines'?: Array<FooterLine>;
    /**
     * 
     * @type {string}
     * @memberof RevCommit
     */
    'fullMessage'?: string;
    /**
     * 
     * @type {ObjectId}
     * @memberof RevCommit
     */
    'id'?: ObjectId;
    /**
     * 
     * @type {string}
     * @memberof RevCommit
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof RevCommit
     */
    'parentCount'?: number;
    /**
     * 
     * @type {Array<RevCommit>}
     * @memberof RevCommit
     */
    'parents'?: Array<RevCommit>;
    /**
     * 
     * @type {string}
     * @memberof RevCommit
     */
    'rawBuffer'?: string;
    /**
     * 
     * @type {string}
     * @memberof RevCommit
     */
    'shortMessage'?: string;
    /**
     * 
     * @type {RevTree}
     * @memberof RevCommit
     */
    'tree'?: RevTree;
    /**
     * 
     * @type {number}
     * @memberof RevCommit
     */
    'type'?: number;
}
/**
 * 
 * @export
 * @interface RevTree
 */
export interface RevTree {
    /**
     * 
     * @type {number}
     * @memberof RevTree
     */
    'firstByte'?: number;
    /**
     * 
     * @type {ObjectId}
     * @memberof RevTree
     */
    'id'?: ObjectId;
    /**
     * 
     * @type {string}
     * @memberof RevTree
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof RevTree
     */
    'type'?: number;
}
/**
 * 
 * @export
 * @interface TimeZone
 */
export interface TimeZone {
    /**
     * 
     * @type {string}
     * @memberof TimeZone
     */
    'displayName'?: string;
    /**
     * 
     * @type {number}
     * @memberof TimeZone
     */
    'dstsavings'?: number;
    /**
     * 
     * @type {string}
     * @memberof TimeZone
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof TimeZone
     */
    'rawOffset'?: number;
}
/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'contentType'?: string;
}

/**
 * BasicErrorControllerApi - axios parameter creator
 * @export
 */
export const BasicErrorControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasicErrorControllerApi - functional programming interface
 * @export
 */
export const BasicErrorControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BasicErrorControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingDELETE(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingDELETE(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingHEAD(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingHEAD(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingOPTIONS(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingOPTIONS(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingPATCH(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingPATCH(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingPOST(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingPUT(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingPUT(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BasicErrorControllerApi - factory interface
 * @export
 */
export const BasicErrorControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BasicErrorControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingDELETE(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingHEAD(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingOPTIONS(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingPATCH(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingPUT(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BasicErrorControllerApi - object-oriented interface
 * @export
 * @class BasicErrorControllerApi
 * @extends {BaseAPI}
 */
export class BasicErrorControllerApi extends BaseAPI {
    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingDELETE(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingDELETE(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingGET(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingHEAD(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingHEAD(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingOPTIONS(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingOPTIONS(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPATCH(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPATCH(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPOST(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPUT(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPUT(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DecompositionControllerImplApi - axios parameter creator
 * @export
 */
export const DecompositionControllerImplApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary decomposeRepositoryByIdAsGraphVisualization
         * @param {number} repositoryId repositoryId
         * @param {DecompositionCouplingParametersDto} decompositionParameters decompositionParameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decomposeRepositoryByIdAsGraphVisualizationUsingPOST: async (repositoryId: number, decompositionParameters: DecompositionCouplingParametersDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('decomposeRepositoryByIdAsGraphVisualizationUsingPOST', 'repositoryId', repositoryId)
            // verify required parameter 'decompositionParameters' is not null or undefined
            assertParamExists('decomposeRepositoryByIdAsGraphVisualizationUsingPOST', 'decompositionParameters', decompositionParameters)
            const localVarPath = `/decompositions/decompose/{repositoryId}/visualization`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(decompositionParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary decomposeRepositoryByIdAsGraphviz
         * @param {number} repoId repoId
         * @param {DecompositionCouplingParametersDto} decompositionDTO decompositionDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decomposeRepositoryByIdAsGraphvizUsingPOST: async (repoId: number, decompositionDTO: DecompositionCouplingParametersDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoId' is not null or undefined
            assertParamExists('decomposeRepositoryByIdAsGraphvizUsingPOST', 'repoId', repoId)
            // verify required parameter 'decompositionDTO' is not null or undefined
            assertParamExists('decomposeRepositoryByIdAsGraphvizUsingPOST', 'decompositionDTO', decompositionDTO)
            const localVarPath = `/decompositions/decompose/{repoId}/graphviz`
                .replace(`{${"repoId"}}`, encodeURIComponent(String(repoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(decompositionDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary decomposeRepositoryById
         * @param {number} repoId repoId
         * @param {DecompositionCouplingParametersDto} decompositionDTO decompositionDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decomposeRepositoryByIdUsingPOST: async (repoId: number, decompositionDTO: DecompositionCouplingParametersDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoId' is not null or undefined
            assertParamExists('decomposeRepositoryByIdUsingPOST', 'repoId', repoId)
            // verify required parameter 'decompositionDTO' is not null or undefined
            assertParamExists('decomposeRepositoryByIdUsingPOST', 'decompositionDTO', decompositionDTO)
            const localVarPath = `/decompositions/decompose/{repoId}`
                .replace(`{${"repoId"}}`, encodeURIComponent(String(repoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(decompositionDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllDecompositions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDecompositionsUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/decompositions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDecompositionByIdAsGraph
         * @param {number} decompositionId decompositionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDecompositionByIdAsGraphUsingGET: async (decompositionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'decompositionId' is not null or undefined
            assertParamExists('getDecompositionByIdAsGraphUsingGET', 'decompositionId', decompositionId)
            const localVarPath = `/decompositions/{decompositionId}/graph`
                .replace(`{${"decompositionId"}}`, encodeURIComponent(String(decompositionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDecompositionByIdAsVisualization
         * @param {number} decompositionId decompositionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDecompositionByIdAsVisualizationUsingGET: async (decompositionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'decompositionId' is not null or undefined
            assertParamExists('getDecompositionByIdAsVisualizationUsingGET', 'decompositionId', decompositionId)
            const localVarPath = `/decompositions/{decompositionId}/visualization`
                .replace(`{${"decompositionId"}}`, encodeURIComponent(String(decompositionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDecompositionById
         * @param {number} decompositionId decompositionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDecompositionByIdUsingGET: async (decompositionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'decompositionId' is not null or undefined
            assertParamExists('getDecompositionByIdUsingGET', 'decompositionId', decompositionId)
            const localVarPath = `/decompositions/{decompositionId}`
                .replace(`{${"decompositionId"}}`, encodeURIComponent(String(decompositionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary monolithicCouplingVisualization
         * @param {number} repositoryId repositoryId
         * @param {MonolithCouplingParametersDto} monolithCouplingParametersDto monolithCouplingParametersDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monolithicCouplingVisualizationUsingPOST: async (repositoryId: number, monolithCouplingParametersDto: MonolithCouplingParametersDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('monolithicCouplingVisualizationUsingPOST', 'repositoryId', repositoryId)
            // verify required parameter 'monolithCouplingParametersDto' is not null or undefined
            assertParamExists('monolithicCouplingVisualizationUsingPOST', 'monolithCouplingParametersDto', monolithCouplingParametersDto)
            const localVarPath = `/decompositions/monolith/{repositoryId}/coupling/visualization`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(monolithCouplingParametersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DecompositionControllerImplApi - functional programming interface
 * @export
 */
export const DecompositionControllerImplApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DecompositionControllerImplApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary decomposeRepositoryByIdAsGraphVisualization
         * @param {number} repositoryId repositoryId
         * @param {DecompositionCouplingParametersDto} decompositionParameters decompositionParameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decomposeRepositoryByIdAsGraphVisualizationUsingPOST(repositoryId: number, decompositionParameters: DecompositionCouplingParametersDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphVisualizationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.decomposeRepositoryByIdAsGraphVisualizationUsingPOST(repositoryId, decompositionParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary decomposeRepositoryByIdAsGraphviz
         * @param {number} repoId repoId
         * @param {DecompositionCouplingParametersDto} decompositionDTO decompositionDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decomposeRepositoryByIdAsGraphvizUsingPOST(repoId: number, decompositionDTO: DecompositionCouplingParametersDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.decomposeRepositoryByIdAsGraphvizUsingPOST(repoId, decompositionDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary decomposeRepositoryById
         * @param {number} repoId repoId
         * @param {DecompositionCouplingParametersDto} decompositionDTO decompositionDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decomposeRepositoryByIdUsingPOST(repoId: number, decompositionDTO: DecompositionCouplingParametersDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GraphRepresentation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.decomposeRepositoryByIdUsingPOST(repoId, decompositionDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllDecompositions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDecompositionsUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DecompositionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDecompositionsUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getDecompositionByIdAsGraph
         * @param {number} decompositionId decompositionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDecompositionByIdAsGraphUsingGET(decompositionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GraphRepresentation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDecompositionByIdAsGraphUsingGET(decompositionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getDecompositionByIdAsVisualization
         * @param {number} decompositionId decompositionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDecompositionByIdAsVisualizationUsingGET(decompositionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphVisualizationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDecompositionByIdAsVisualizationUsingGET(decompositionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getDecompositionById
         * @param {number} decompositionId decompositionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDecompositionByIdUsingGET(decompositionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Decomposition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDecompositionByIdUsingGET(decompositionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary monolithicCouplingVisualization
         * @param {number} repositoryId repositoryId
         * @param {MonolithCouplingParametersDto} monolithCouplingParametersDto monolithCouplingParametersDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async monolithicCouplingVisualizationUsingPOST(repositoryId: number, monolithCouplingParametersDto: MonolithCouplingParametersDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphVisualizationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.monolithicCouplingVisualizationUsingPOST(repositoryId, monolithCouplingParametersDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DecompositionControllerImplApi - factory interface
 * @export
 */
export const DecompositionControllerImplApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DecompositionControllerImplApiFp(configuration)
    return {
        /**
         * 
         * @summary decomposeRepositoryByIdAsGraphVisualization
         * @param {number} repositoryId repositoryId
         * @param {DecompositionCouplingParametersDto} decompositionParameters decompositionParameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decomposeRepositoryByIdAsGraphVisualizationUsingPOST(repositoryId: number, decompositionParameters: DecompositionCouplingParametersDto, options?: any): AxiosPromise<GraphVisualizationDto> {
            return localVarFp.decomposeRepositoryByIdAsGraphVisualizationUsingPOST(repositoryId, decompositionParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary decomposeRepositoryByIdAsGraphviz
         * @param {number} repoId repoId
         * @param {DecompositionCouplingParametersDto} decompositionDTO decompositionDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decomposeRepositoryByIdAsGraphvizUsingPOST(repoId: number, decompositionDTO: DecompositionCouplingParametersDto, options?: any): AxiosPromise<string> {
            return localVarFp.decomposeRepositoryByIdAsGraphvizUsingPOST(repoId, decompositionDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary decomposeRepositoryById
         * @param {number} repoId repoId
         * @param {DecompositionCouplingParametersDto} decompositionDTO decompositionDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decomposeRepositoryByIdUsingPOST(repoId: number, decompositionDTO: DecompositionCouplingParametersDto, options?: any): AxiosPromise<Array<GraphRepresentation>> {
            return localVarFp.decomposeRepositoryByIdUsingPOST(repoId, decompositionDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllDecompositions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDecompositionsUsingGET(options?: any): AxiosPromise<Array<DecompositionDto>> {
            return localVarFp.getAllDecompositionsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getDecompositionByIdAsGraph
         * @param {number} decompositionId decompositionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDecompositionByIdAsGraphUsingGET(decompositionId: number, options?: any): AxiosPromise<Array<GraphRepresentation>> {
            return localVarFp.getDecompositionByIdAsGraphUsingGET(decompositionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getDecompositionByIdAsVisualization
         * @param {number} decompositionId decompositionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDecompositionByIdAsVisualizationUsingGET(decompositionId: number, options?: any): AxiosPromise<GraphVisualizationDto> {
            return localVarFp.getDecompositionByIdAsVisualizationUsingGET(decompositionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getDecompositionById
         * @param {number} decompositionId decompositionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDecompositionByIdUsingGET(decompositionId: number, options?: any): AxiosPromise<Decomposition> {
            return localVarFp.getDecompositionByIdUsingGET(decompositionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary monolithicCouplingVisualization
         * @param {number} repositoryId repositoryId
         * @param {MonolithCouplingParametersDto} monolithCouplingParametersDto monolithCouplingParametersDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monolithicCouplingVisualizationUsingPOST(repositoryId: number, monolithCouplingParametersDto: MonolithCouplingParametersDto, options?: any): AxiosPromise<GraphVisualizationDto> {
            return localVarFp.monolithicCouplingVisualizationUsingPOST(repositoryId, monolithCouplingParametersDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DecompositionControllerImplApi - object-oriented interface
 * @export
 * @class DecompositionControllerImplApi
 * @extends {BaseAPI}
 */
export class DecompositionControllerImplApi extends BaseAPI {
    /**
     * 
     * @summary decomposeRepositoryByIdAsGraphVisualization
     * @param {number} repositoryId repositoryId
     * @param {DecompositionCouplingParametersDto} decompositionParameters decompositionParameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DecompositionControllerImplApi
     */
    public decomposeRepositoryByIdAsGraphVisualizationUsingPOST(repositoryId: number, decompositionParameters: DecompositionCouplingParametersDto, options?: AxiosRequestConfig) {
        return DecompositionControllerImplApiFp(this.configuration).decomposeRepositoryByIdAsGraphVisualizationUsingPOST(repositoryId, decompositionParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary decomposeRepositoryByIdAsGraphviz
     * @param {number} repoId repoId
     * @param {DecompositionCouplingParametersDto} decompositionDTO decompositionDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DecompositionControllerImplApi
     */
    public decomposeRepositoryByIdAsGraphvizUsingPOST(repoId: number, decompositionDTO: DecompositionCouplingParametersDto, options?: AxiosRequestConfig) {
        return DecompositionControllerImplApiFp(this.configuration).decomposeRepositoryByIdAsGraphvizUsingPOST(repoId, decompositionDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary decomposeRepositoryById
     * @param {number} repoId repoId
     * @param {DecompositionCouplingParametersDto} decompositionDTO decompositionDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DecompositionControllerImplApi
     */
    public decomposeRepositoryByIdUsingPOST(repoId: number, decompositionDTO: DecompositionCouplingParametersDto, options?: AxiosRequestConfig) {
        return DecompositionControllerImplApiFp(this.configuration).decomposeRepositoryByIdUsingPOST(repoId, decompositionDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllDecompositions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DecompositionControllerImplApi
     */
    public getAllDecompositionsUsingGET(options?: AxiosRequestConfig) {
        return DecompositionControllerImplApiFp(this.configuration).getAllDecompositionsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getDecompositionByIdAsGraph
     * @param {number} decompositionId decompositionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DecompositionControllerImplApi
     */
    public getDecompositionByIdAsGraphUsingGET(decompositionId: number, options?: AxiosRequestConfig) {
        return DecompositionControllerImplApiFp(this.configuration).getDecompositionByIdAsGraphUsingGET(decompositionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getDecompositionByIdAsVisualization
     * @param {number} decompositionId decompositionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DecompositionControllerImplApi
     */
    public getDecompositionByIdAsVisualizationUsingGET(decompositionId: number, options?: AxiosRequestConfig) {
        return DecompositionControllerImplApiFp(this.configuration).getDecompositionByIdAsVisualizationUsingGET(decompositionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getDecompositionById
     * @param {number} decompositionId decompositionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DecompositionControllerImplApi
     */
    public getDecompositionByIdUsingGET(decompositionId: number, options?: AxiosRequestConfig) {
        return DecompositionControllerImplApiFp(this.configuration).getDecompositionByIdUsingGET(decompositionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary monolithicCouplingVisualization
     * @param {number} repositoryId repositoryId
     * @param {MonolithCouplingParametersDto} monolithCouplingParametersDto monolithCouplingParametersDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DecompositionControllerImplApi
     */
    public monolithicCouplingVisualizationUsingPOST(repositoryId: number, monolithCouplingParametersDto: MonolithCouplingParametersDto, options?: AxiosRequestConfig) {
        return DecompositionControllerImplApiFp(this.configuration).monolithicCouplingVisualizationUsingPOST(repositoryId, monolithCouplingParametersDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EvaluationControllerImplApi - axios parameter creator
 * @export
 */
export const EvaluationControllerImplApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary exportPerformanceMetrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPerformanceMetricsUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/evaluations/performance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary exportQualityMetrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportQualityMetricsUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/evaluations/quality`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EvaluationControllerImplApi - functional programming interface
 * @export
 */
export const EvaluationControllerImplApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EvaluationControllerImplApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary exportPerformanceMetrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportPerformanceMetricsUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PerformanceMetricsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportPerformanceMetricsUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary exportQualityMetrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportQualityMetricsUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<QualityMetricDto>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportQualityMetricsUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EvaluationControllerImplApi - factory interface
 * @export
 */
export const EvaluationControllerImplApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EvaluationControllerImplApiFp(configuration)
    return {
        /**
         * 
         * @summary exportPerformanceMetrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPerformanceMetricsUsingGET(options?: any): AxiosPromise<PerformanceMetricsDto> {
            return localVarFp.exportPerformanceMetricsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary exportQualityMetrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportQualityMetricsUsingGET(options?: any): AxiosPromise<Array<Array<QualityMetricDto>>> {
            return localVarFp.exportQualityMetricsUsingGET(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EvaluationControllerImplApi - object-oriented interface
 * @export
 * @class EvaluationControllerImplApi
 * @extends {BaseAPI}
 */
export class EvaluationControllerImplApi extends BaseAPI {
    /**
     * 
     * @summary exportPerformanceMetrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationControllerImplApi
     */
    public exportPerformanceMetricsUsingGET(options?: AxiosRequestConfig) {
        return EvaluationControllerImplApiFp(this.configuration).exportPerformanceMetricsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary exportQualityMetrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationControllerImplApi
     */
    public exportQualityMetricsUsingGET(options?: AxiosRequestConfig) {
        return EvaluationControllerImplApiFp(this.configuration).exportQualityMetricsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepositoryControllerImplApi - axios parameter creator
 * @export
 */
export const RepositoryControllerImplApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addRepository
         * @param {RepositoryDto} repositoryDto repositoryDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRepositoryUsingPOST: async (repositoryDto: RepositoryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryDto' is not null or undefined
            assertParamExists('addRepositoryUsingPOST', 'repositoryDto', repositoryDto)
            const localVarPath = `/repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repositoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllRepositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositoriesUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRepositoryById
         * @param {number} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryByIdUsingGET: async (repositoryId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getRepositoryByIdUsingGET', 'repositoryId', repositoryId)
            const localVarPath = `/repositories/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryControllerImplApi - functional programming interface
 * @export
 */
export const RepositoryControllerImplApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoryControllerImplApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary addRepository
         * @param {RepositoryDto} repositoryDto repositoryDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRepositoryUsingPOST(repositoryDto: RepositoryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRepositoryUsingPOST(repositoryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllRepositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRepositoriesUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GitRepository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRepositoriesUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getRepositoryById
         * @param {number} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryByIdUsingGET(repositoryId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryByIdUsingGET(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoryControllerImplApi - factory interface
 * @export
 */
export const RepositoryControllerImplApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoryControllerImplApiFp(configuration)
    return {
        /**
         * 
         * @summary addRepository
         * @param {RepositoryDto} repositoryDto repositoryDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRepositoryUsingPOST(repositoryDto: RepositoryDto, options?: any): AxiosPromise<GitRepository> {
            return localVarFp.addRepositoryUsingPOST(repositoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllRepositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositoriesUsingGET(options?: any): AxiosPromise<Array<GitRepository>> {
            return localVarFp.getAllRepositoriesUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getRepositoryById
         * @param {number} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryByIdUsingGET(repositoryId: number, options?: any): AxiosPromise<GitRepository> {
            return localVarFp.getRepositoryByIdUsingGET(repositoryId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryControllerImplApi - object-oriented interface
 * @export
 * @class RepositoryControllerImplApi
 * @extends {BaseAPI}
 */
export class RepositoryControllerImplApi extends BaseAPI {
    /**
     * 
     * @summary addRepository
     * @param {RepositoryDto} repositoryDto repositoryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryControllerImplApi
     */
    public addRepositoryUsingPOST(repositoryDto: RepositoryDto, options?: AxiosRequestConfig) {
        return RepositoryControllerImplApiFp(this.configuration).addRepositoryUsingPOST(repositoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllRepositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryControllerImplApi
     */
    public getAllRepositoriesUsingGET(options?: AxiosRequestConfig) {
        return RepositoryControllerImplApiFp(this.configuration).getAllRepositoriesUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getRepositoryById
     * @param {number} repositoryId repositoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryControllerImplApi
     */
    public getRepositoryByIdUsingGET(repositoryId: number, options?: AxiosRequestConfig) {
        return RepositoryControllerImplApiFp(this.configuration).getRepositoryByIdUsingGET(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }
}


